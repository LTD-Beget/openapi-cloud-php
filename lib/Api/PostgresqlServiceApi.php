<?php
/**
 * PostgresqlServiceApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * API Управляемых сервисов
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.6.1
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * PostgresqlServiceApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PostgresqlServiceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'postgresqlServiceCreateDb' => [
            'application/json',
        ],
        'postgresqlServiceCreateRole' => [
            'application/json',
        ],
        'postgresqlServiceGetConfig' => [
            'application/json',
        ],
        'postgresqlServiceGetDbList' => [
            'application/json',
        ],
        'postgresqlServiceGetRemoteAccess' => [
            'application/json',
        ],
        'postgresqlServiceGetRoleList' => [
            'application/json',
        ],
        'postgresqlServiceRemoveDb' => [
            'application/json',
        ],
        'postgresqlServiceRemoveRole' => [
            'application/json',
        ],
        'postgresqlServiceSetConfig' => [
            'application/json',
        ],
        'postgresqlServiceUpdateDb' => [
            'application/json',
        ],
        'postgresqlServiceUpdateRemoteAccess' => [
            'application/json',
        ],
        'postgresqlServiceUpdateRole' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation postgresqlServiceCreateDb
     *
     * @param  string $service_id service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgCreateDbRequest $postgresql_pg_create_db_request postgresql_pg_create_db_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceCreateDb'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostgresqlPgCreateDbResponse
     */
    public function postgresqlServiceCreateDb($service_id, $postgresql_pg_create_db_request, string $contentType = self::contentTypes['postgresqlServiceCreateDb'][0])
    {
        list($response) = $this->postgresqlServiceCreateDbWithHttpInfo($service_id, $postgresql_pg_create_db_request, $contentType);
        return $response;
    }

    /**
     * Operation postgresqlServiceCreateDbWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgCreateDbRequest $postgresql_pg_create_db_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceCreateDb'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostgresqlPgCreateDbResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postgresqlServiceCreateDbWithHttpInfo($service_id, $postgresql_pg_create_db_request, string $contentType = self::contentTypes['postgresqlServiceCreateDb'][0])
    {
        $request = $this->postgresqlServiceCreateDbRequest($service_id, $postgresql_pg_create_db_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PostgresqlPgCreateDbResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PostgresqlPgCreateDbResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PostgresqlPgCreateDbResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PostgresqlPgCreateDbResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostgresqlPgCreateDbResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postgresqlServiceCreateDbAsync
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgCreateDbRequest $postgresql_pg_create_db_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceCreateDb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceCreateDbAsync($service_id, $postgresql_pg_create_db_request, string $contentType = self::contentTypes['postgresqlServiceCreateDb'][0])
    {
        return $this->postgresqlServiceCreateDbAsyncWithHttpInfo($service_id, $postgresql_pg_create_db_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postgresqlServiceCreateDbAsyncWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgCreateDbRequest $postgresql_pg_create_db_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceCreateDb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceCreateDbAsyncWithHttpInfo($service_id, $postgresql_pg_create_db_request, string $contentType = self::contentTypes['postgresqlServiceCreateDb'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostgresqlPgCreateDbResponse';
        $request = $this->postgresqlServiceCreateDbRequest($service_id, $postgresql_pg_create_db_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postgresqlServiceCreateDb'
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgCreateDbRequest $postgresql_pg_create_db_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceCreateDb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postgresqlServiceCreateDbRequest($service_id, $postgresql_pg_create_db_request, string $contentType = self::contentTypes['postgresqlServiceCreateDb'][0])
    {

        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling postgresqlServiceCreateDb'
            );
        }

        // verify the required parameter 'postgresql_pg_create_db_request' is set
        if ($postgresql_pg_create_db_request === null || (is_array($postgresql_pg_create_db_request) && count($postgresql_pg_create_db_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $postgresql_pg_create_db_request when calling postgresqlServiceCreateDb'
            );
        }


        $resourcePath = '/v1/cloud/postgresql/{service_id}/db';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($postgresql_pg_create_db_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($postgresql_pg_create_db_request));
            } else {
                $httpBody = $postgresql_pg_create_db_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postgresqlServiceCreateRole
     *
     * @param  string $service_id service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgCreateRoleRequest $postgresql_pg_create_role_request postgresql_pg_create_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceCreateRole'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostgresqlPgCreateRoleResponse
     */
    public function postgresqlServiceCreateRole($service_id, $postgresql_pg_create_role_request, string $contentType = self::contentTypes['postgresqlServiceCreateRole'][0])
    {
        list($response) = $this->postgresqlServiceCreateRoleWithHttpInfo($service_id, $postgresql_pg_create_role_request, $contentType);
        return $response;
    }

    /**
     * Operation postgresqlServiceCreateRoleWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgCreateRoleRequest $postgresql_pg_create_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceCreateRole'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostgresqlPgCreateRoleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postgresqlServiceCreateRoleWithHttpInfo($service_id, $postgresql_pg_create_role_request, string $contentType = self::contentTypes['postgresqlServiceCreateRole'][0])
    {
        $request = $this->postgresqlServiceCreateRoleRequest($service_id, $postgresql_pg_create_role_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PostgresqlPgCreateRoleResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PostgresqlPgCreateRoleResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PostgresqlPgCreateRoleResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PostgresqlPgCreateRoleResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostgresqlPgCreateRoleResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postgresqlServiceCreateRoleAsync
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgCreateRoleRequest $postgresql_pg_create_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceCreateRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceCreateRoleAsync($service_id, $postgresql_pg_create_role_request, string $contentType = self::contentTypes['postgresqlServiceCreateRole'][0])
    {
        return $this->postgresqlServiceCreateRoleAsyncWithHttpInfo($service_id, $postgresql_pg_create_role_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postgresqlServiceCreateRoleAsyncWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgCreateRoleRequest $postgresql_pg_create_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceCreateRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceCreateRoleAsyncWithHttpInfo($service_id, $postgresql_pg_create_role_request, string $contentType = self::contentTypes['postgresqlServiceCreateRole'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostgresqlPgCreateRoleResponse';
        $request = $this->postgresqlServiceCreateRoleRequest($service_id, $postgresql_pg_create_role_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postgresqlServiceCreateRole'
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgCreateRoleRequest $postgresql_pg_create_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceCreateRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postgresqlServiceCreateRoleRequest($service_id, $postgresql_pg_create_role_request, string $contentType = self::contentTypes['postgresqlServiceCreateRole'][0])
    {

        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling postgresqlServiceCreateRole'
            );
        }

        // verify the required parameter 'postgresql_pg_create_role_request' is set
        if ($postgresql_pg_create_role_request === null || (is_array($postgresql_pg_create_role_request) && count($postgresql_pg_create_role_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $postgresql_pg_create_role_request when calling postgresqlServiceCreateRole'
            );
        }


        $resourcePath = '/v1/cloud/postgresql/{service_id}/role';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($postgresql_pg_create_role_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($postgresql_pg_create_role_request));
            } else {
                $httpBody = $postgresql_pg_create_role_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postgresqlServiceGetConfig
     *
     * @param  string $service_id service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostgresqlPgGetConfigResponse
     */
    public function postgresqlServiceGetConfig($service_id, string $contentType = self::contentTypes['postgresqlServiceGetConfig'][0])
    {
        list($response) = $this->postgresqlServiceGetConfigWithHttpInfo($service_id, $contentType);
        return $response;
    }

    /**
     * Operation postgresqlServiceGetConfigWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostgresqlPgGetConfigResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postgresqlServiceGetConfigWithHttpInfo($service_id, string $contentType = self::contentTypes['postgresqlServiceGetConfig'][0])
    {
        $request = $this->postgresqlServiceGetConfigRequest($service_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PostgresqlPgGetConfigResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PostgresqlPgGetConfigResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PostgresqlPgGetConfigResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PostgresqlPgGetConfigResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostgresqlPgGetConfigResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postgresqlServiceGetConfigAsync
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceGetConfigAsync($service_id, string $contentType = self::contentTypes['postgresqlServiceGetConfig'][0])
    {
        return $this->postgresqlServiceGetConfigAsyncWithHttpInfo($service_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postgresqlServiceGetConfigAsyncWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceGetConfigAsyncWithHttpInfo($service_id, string $contentType = self::contentTypes['postgresqlServiceGetConfig'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostgresqlPgGetConfigResponse';
        $request = $this->postgresqlServiceGetConfigRequest($service_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postgresqlServiceGetConfig'
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postgresqlServiceGetConfigRequest($service_id, string $contentType = self::contentTypes['postgresqlServiceGetConfig'][0])
    {

        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling postgresqlServiceGetConfig'
            );
        }


        $resourcePath = '/v1/cloud/postgresql/{service_id}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postgresqlServiceGetDbList
     *
     * @param  string $service_id service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetDbList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostgresqlPgGetDbListResponse
     */
    public function postgresqlServiceGetDbList($service_id, string $contentType = self::contentTypes['postgresqlServiceGetDbList'][0])
    {
        list($response) = $this->postgresqlServiceGetDbListWithHttpInfo($service_id, $contentType);
        return $response;
    }

    /**
     * Operation postgresqlServiceGetDbListWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetDbList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostgresqlPgGetDbListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postgresqlServiceGetDbListWithHttpInfo($service_id, string $contentType = self::contentTypes['postgresqlServiceGetDbList'][0])
    {
        $request = $this->postgresqlServiceGetDbListRequest($service_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PostgresqlPgGetDbListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PostgresqlPgGetDbListResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PostgresqlPgGetDbListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PostgresqlPgGetDbListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostgresqlPgGetDbListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postgresqlServiceGetDbListAsync
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetDbList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceGetDbListAsync($service_id, string $contentType = self::contentTypes['postgresqlServiceGetDbList'][0])
    {
        return $this->postgresqlServiceGetDbListAsyncWithHttpInfo($service_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postgresqlServiceGetDbListAsyncWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetDbList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceGetDbListAsyncWithHttpInfo($service_id, string $contentType = self::contentTypes['postgresqlServiceGetDbList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostgresqlPgGetDbListResponse';
        $request = $this->postgresqlServiceGetDbListRequest($service_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postgresqlServiceGetDbList'
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetDbList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postgresqlServiceGetDbListRequest($service_id, string $contentType = self::contentTypes['postgresqlServiceGetDbList'][0])
    {

        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling postgresqlServiceGetDbList'
            );
        }


        $resourcePath = '/v1/cloud/postgresql/{service_id}/db';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postgresqlServiceGetRemoteAccess
     *
     * @param  string $service_id service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetRemoteAccess'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostgresqlPgGetRemoteAccessResponse
     */
    public function postgresqlServiceGetRemoteAccess($service_id, string $contentType = self::contentTypes['postgresqlServiceGetRemoteAccess'][0])
    {
        list($response) = $this->postgresqlServiceGetRemoteAccessWithHttpInfo($service_id, $contentType);
        return $response;
    }

    /**
     * Operation postgresqlServiceGetRemoteAccessWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetRemoteAccess'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostgresqlPgGetRemoteAccessResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postgresqlServiceGetRemoteAccessWithHttpInfo($service_id, string $contentType = self::contentTypes['postgresqlServiceGetRemoteAccess'][0])
    {
        $request = $this->postgresqlServiceGetRemoteAccessRequest($service_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PostgresqlPgGetRemoteAccessResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PostgresqlPgGetRemoteAccessResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PostgresqlPgGetRemoteAccessResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PostgresqlPgGetRemoteAccessResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostgresqlPgGetRemoteAccessResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postgresqlServiceGetRemoteAccessAsync
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetRemoteAccess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceGetRemoteAccessAsync($service_id, string $contentType = self::contentTypes['postgresqlServiceGetRemoteAccess'][0])
    {
        return $this->postgresqlServiceGetRemoteAccessAsyncWithHttpInfo($service_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postgresqlServiceGetRemoteAccessAsyncWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetRemoteAccess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceGetRemoteAccessAsyncWithHttpInfo($service_id, string $contentType = self::contentTypes['postgresqlServiceGetRemoteAccess'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostgresqlPgGetRemoteAccessResponse';
        $request = $this->postgresqlServiceGetRemoteAccessRequest($service_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postgresqlServiceGetRemoteAccess'
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetRemoteAccess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postgresqlServiceGetRemoteAccessRequest($service_id, string $contentType = self::contentTypes['postgresqlServiceGetRemoteAccess'][0])
    {

        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling postgresqlServiceGetRemoteAccess'
            );
        }


        $resourcePath = '/v1/cloud/postgresql/{service_id}/remote-access';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postgresqlServiceGetRoleList
     *
     * @param  string $service_id service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetRoleList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostgresqlPgGetRoleListResponse
     */
    public function postgresqlServiceGetRoleList($service_id, string $contentType = self::contentTypes['postgresqlServiceGetRoleList'][0])
    {
        list($response) = $this->postgresqlServiceGetRoleListWithHttpInfo($service_id, $contentType);
        return $response;
    }

    /**
     * Operation postgresqlServiceGetRoleListWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetRoleList'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostgresqlPgGetRoleListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postgresqlServiceGetRoleListWithHttpInfo($service_id, string $contentType = self::contentTypes['postgresqlServiceGetRoleList'][0])
    {
        $request = $this->postgresqlServiceGetRoleListRequest($service_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PostgresqlPgGetRoleListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PostgresqlPgGetRoleListResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PostgresqlPgGetRoleListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PostgresqlPgGetRoleListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostgresqlPgGetRoleListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postgresqlServiceGetRoleListAsync
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetRoleList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceGetRoleListAsync($service_id, string $contentType = self::contentTypes['postgresqlServiceGetRoleList'][0])
    {
        return $this->postgresqlServiceGetRoleListAsyncWithHttpInfo($service_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postgresqlServiceGetRoleListAsyncWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetRoleList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceGetRoleListAsyncWithHttpInfo($service_id, string $contentType = self::contentTypes['postgresqlServiceGetRoleList'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostgresqlPgGetRoleListResponse';
        $request = $this->postgresqlServiceGetRoleListRequest($service_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postgresqlServiceGetRoleList'
     *
     * @param  string $service_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceGetRoleList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postgresqlServiceGetRoleListRequest($service_id, string $contentType = self::contentTypes['postgresqlServiceGetRoleList'][0])
    {

        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling postgresqlServiceGetRoleList'
            );
        }


        $resourcePath = '/v1/cloud/postgresql/{service_id}/role';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postgresqlServiceRemoveDb
     *
     * @param  string $service_id service_id (required)
     * @param  string $db_name db_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceRemoveDb'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostgresqlPgRemoveDbResponse
     */
    public function postgresqlServiceRemoveDb($service_id, $db_name, string $contentType = self::contentTypes['postgresqlServiceRemoveDb'][0])
    {
        list($response) = $this->postgresqlServiceRemoveDbWithHttpInfo($service_id, $db_name, $contentType);
        return $response;
    }

    /**
     * Operation postgresqlServiceRemoveDbWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $db_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceRemoveDb'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostgresqlPgRemoveDbResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postgresqlServiceRemoveDbWithHttpInfo($service_id, $db_name, string $contentType = self::contentTypes['postgresqlServiceRemoveDb'][0])
    {
        $request = $this->postgresqlServiceRemoveDbRequest($service_id, $db_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PostgresqlPgRemoveDbResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PostgresqlPgRemoveDbResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PostgresqlPgRemoveDbResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PostgresqlPgRemoveDbResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostgresqlPgRemoveDbResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postgresqlServiceRemoveDbAsync
     *
     * @param  string $service_id (required)
     * @param  string $db_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceRemoveDb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceRemoveDbAsync($service_id, $db_name, string $contentType = self::contentTypes['postgresqlServiceRemoveDb'][0])
    {
        return $this->postgresqlServiceRemoveDbAsyncWithHttpInfo($service_id, $db_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postgresqlServiceRemoveDbAsyncWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $db_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceRemoveDb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceRemoveDbAsyncWithHttpInfo($service_id, $db_name, string $contentType = self::contentTypes['postgresqlServiceRemoveDb'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostgresqlPgRemoveDbResponse';
        $request = $this->postgresqlServiceRemoveDbRequest($service_id, $db_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postgresqlServiceRemoveDb'
     *
     * @param  string $service_id (required)
     * @param  string $db_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceRemoveDb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postgresqlServiceRemoveDbRequest($service_id, $db_name, string $contentType = self::contentTypes['postgresqlServiceRemoveDb'][0])
    {

        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling postgresqlServiceRemoveDb'
            );
        }

        // verify the required parameter 'db_name' is set
        if ($db_name === null || (is_array($db_name) && count($db_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db_name when calling postgresqlServiceRemoveDb'
            );
        }


        $resourcePath = '/v1/cloud/postgresql/{service_id}/db/{db_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($db_name !== null) {
            $resourcePath = str_replace(
                '{' . 'db_name' . '}',
                ObjectSerializer::toPathValue($db_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postgresqlServiceRemoveRole
     *
     * @param  string $service_id service_id (required)
     * @param  string $role_name role_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceRemoveRole'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostgresqlPgRemoveRoleResponse
     */
    public function postgresqlServiceRemoveRole($service_id, $role_name, string $contentType = self::contentTypes['postgresqlServiceRemoveRole'][0])
    {
        list($response) = $this->postgresqlServiceRemoveRoleWithHttpInfo($service_id, $role_name, $contentType);
        return $response;
    }

    /**
     * Operation postgresqlServiceRemoveRoleWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $role_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceRemoveRole'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostgresqlPgRemoveRoleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postgresqlServiceRemoveRoleWithHttpInfo($service_id, $role_name, string $contentType = self::contentTypes['postgresqlServiceRemoveRole'][0])
    {
        $request = $this->postgresqlServiceRemoveRoleRequest($service_id, $role_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PostgresqlPgRemoveRoleResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PostgresqlPgRemoveRoleResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PostgresqlPgRemoveRoleResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PostgresqlPgRemoveRoleResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostgresqlPgRemoveRoleResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postgresqlServiceRemoveRoleAsync
     *
     * @param  string $service_id (required)
     * @param  string $role_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceRemoveRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceRemoveRoleAsync($service_id, $role_name, string $contentType = self::contentTypes['postgresqlServiceRemoveRole'][0])
    {
        return $this->postgresqlServiceRemoveRoleAsyncWithHttpInfo($service_id, $role_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postgresqlServiceRemoveRoleAsyncWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $role_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceRemoveRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceRemoveRoleAsyncWithHttpInfo($service_id, $role_name, string $contentType = self::contentTypes['postgresqlServiceRemoveRole'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostgresqlPgRemoveRoleResponse';
        $request = $this->postgresqlServiceRemoveRoleRequest($service_id, $role_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postgresqlServiceRemoveRole'
     *
     * @param  string $service_id (required)
     * @param  string $role_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceRemoveRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postgresqlServiceRemoveRoleRequest($service_id, $role_name, string $contentType = self::contentTypes['postgresqlServiceRemoveRole'][0])
    {

        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling postgresqlServiceRemoveRole'
            );
        }

        // verify the required parameter 'role_name' is set
        if ($role_name === null || (is_array($role_name) && count($role_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $role_name when calling postgresqlServiceRemoveRole'
            );
        }


        $resourcePath = '/v1/cloud/postgresql/{service_id}/role/{role_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($role_name !== null) {
            $resourcePath = str_replace(
                '{' . 'role_name' . '}',
                ObjectSerializer::toPathValue($role_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postgresqlServiceSetConfig
     *
     * @param  string $service_id service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgSetConfigRequest $postgresql_pg_set_config_request postgresql_pg_set_config_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceSetConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostgresqlPgSetConfigResponse
     */
    public function postgresqlServiceSetConfig($service_id, $postgresql_pg_set_config_request, string $contentType = self::contentTypes['postgresqlServiceSetConfig'][0])
    {
        list($response) = $this->postgresqlServiceSetConfigWithHttpInfo($service_id, $postgresql_pg_set_config_request, $contentType);
        return $response;
    }

    /**
     * Operation postgresqlServiceSetConfigWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgSetConfigRequest $postgresql_pg_set_config_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceSetConfig'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostgresqlPgSetConfigResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postgresqlServiceSetConfigWithHttpInfo($service_id, $postgresql_pg_set_config_request, string $contentType = self::contentTypes['postgresqlServiceSetConfig'][0])
    {
        $request = $this->postgresqlServiceSetConfigRequest($service_id, $postgresql_pg_set_config_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PostgresqlPgSetConfigResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PostgresqlPgSetConfigResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PostgresqlPgSetConfigResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PostgresqlPgSetConfigResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostgresqlPgSetConfigResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postgresqlServiceSetConfigAsync
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgSetConfigRequest $postgresql_pg_set_config_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceSetConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceSetConfigAsync($service_id, $postgresql_pg_set_config_request, string $contentType = self::contentTypes['postgresqlServiceSetConfig'][0])
    {
        return $this->postgresqlServiceSetConfigAsyncWithHttpInfo($service_id, $postgresql_pg_set_config_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postgresqlServiceSetConfigAsyncWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgSetConfigRequest $postgresql_pg_set_config_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceSetConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceSetConfigAsyncWithHttpInfo($service_id, $postgresql_pg_set_config_request, string $contentType = self::contentTypes['postgresqlServiceSetConfig'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostgresqlPgSetConfigResponse';
        $request = $this->postgresqlServiceSetConfigRequest($service_id, $postgresql_pg_set_config_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postgresqlServiceSetConfig'
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgSetConfigRequest $postgresql_pg_set_config_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceSetConfig'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postgresqlServiceSetConfigRequest($service_id, $postgresql_pg_set_config_request, string $contentType = self::contentTypes['postgresqlServiceSetConfig'][0])
    {

        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling postgresqlServiceSetConfig'
            );
        }

        // verify the required parameter 'postgresql_pg_set_config_request' is set
        if ($postgresql_pg_set_config_request === null || (is_array($postgresql_pg_set_config_request) && count($postgresql_pg_set_config_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $postgresql_pg_set_config_request when calling postgresqlServiceSetConfig'
            );
        }


        $resourcePath = '/v1/cloud/postgresql/{service_id}/config';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($postgresql_pg_set_config_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($postgresql_pg_set_config_request));
            } else {
                $httpBody = $postgresql_pg_set_config_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postgresqlServiceUpdateDb
     *
     * @param  string $service_id service_id (required)
     * @param  string $db_name db_name (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateDbRequest $postgresql_pg_update_db_request postgresql_pg_update_db_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateDb'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostgresqlPgUpdateDbResponse
     */
    public function postgresqlServiceUpdateDb($service_id, $db_name, $postgresql_pg_update_db_request, string $contentType = self::contentTypes['postgresqlServiceUpdateDb'][0])
    {
        list($response) = $this->postgresqlServiceUpdateDbWithHttpInfo($service_id, $db_name, $postgresql_pg_update_db_request, $contentType);
        return $response;
    }

    /**
     * Operation postgresqlServiceUpdateDbWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $db_name (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateDbRequest $postgresql_pg_update_db_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateDb'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostgresqlPgUpdateDbResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postgresqlServiceUpdateDbWithHttpInfo($service_id, $db_name, $postgresql_pg_update_db_request, string $contentType = self::contentTypes['postgresqlServiceUpdateDb'][0])
    {
        $request = $this->postgresqlServiceUpdateDbRequest($service_id, $db_name, $postgresql_pg_update_db_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PostgresqlPgUpdateDbResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PostgresqlPgUpdateDbResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PostgresqlPgUpdateDbResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PostgresqlPgUpdateDbResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostgresqlPgUpdateDbResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postgresqlServiceUpdateDbAsync
     *
     * @param  string $service_id (required)
     * @param  string $db_name (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateDbRequest $postgresql_pg_update_db_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateDb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceUpdateDbAsync($service_id, $db_name, $postgresql_pg_update_db_request, string $contentType = self::contentTypes['postgresqlServiceUpdateDb'][0])
    {
        return $this->postgresqlServiceUpdateDbAsyncWithHttpInfo($service_id, $db_name, $postgresql_pg_update_db_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postgresqlServiceUpdateDbAsyncWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $db_name (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateDbRequest $postgresql_pg_update_db_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateDb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceUpdateDbAsyncWithHttpInfo($service_id, $db_name, $postgresql_pg_update_db_request, string $contentType = self::contentTypes['postgresqlServiceUpdateDb'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostgresqlPgUpdateDbResponse';
        $request = $this->postgresqlServiceUpdateDbRequest($service_id, $db_name, $postgresql_pg_update_db_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postgresqlServiceUpdateDb'
     *
     * @param  string $service_id (required)
     * @param  string $db_name (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateDbRequest $postgresql_pg_update_db_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateDb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postgresqlServiceUpdateDbRequest($service_id, $db_name, $postgresql_pg_update_db_request, string $contentType = self::contentTypes['postgresqlServiceUpdateDb'][0])
    {

        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling postgresqlServiceUpdateDb'
            );
        }

        // verify the required parameter 'db_name' is set
        if ($db_name === null || (is_array($db_name) && count($db_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $db_name when calling postgresqlServiceUpdateDb'
            );
        }

        // verify the required parameter 'postgresql_pg_update_db_request' is set
        if ($postgresql_pg_update_db_request === null || (is_array($postgresql_pg_update_db_request) && count($postgresql_pg_update_db_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $postgresql_pg_update_db_request when calling postgresqlServiceUpdateDb'
            );
        }


        $resourcePath = '/v1/cloud/postgresql/{service_id}/db/{db_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($db_name !== null) {
            $resourcePath = str_replace(
                '{' . 'db_name' . '}',
                ObjectSerializer::toPathValue($db_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($postgresql_pg_update_db_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($postgresql_pg_update_db_request));
            } else {
                $httpBody = $postgresql_pg_update_db_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postgresqlServiceUpdateRemoteAccess
     *
     * @param  string $service_id service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateRemoteAccessRequest $postgresql_pg_update_remote_access_request postgresql_pg_update_remote_access_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateRemoteAccess'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostgresqlPgUpdateRemoteAccessResponse
     */
    public function postgresqlServiceUpdateRemoteAccess($service_id, $postgresql_pg_update_remote_access_request, string $contentType = self::contentTypes['postgresqlServiceUpdateRemoteAccess'][0])
    {
        list($response) = $this->postgresqlServiceUpdateRemoteAccessWithHttpInfo($service_id, $postgresql_pg_update_remote_access_request, $contentType);
        return $response;
    }

    /**
     * Operation postgresqlServiceUpdateRemoteAccessWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateRemoteAccessRequest $postgresql_pg_update_remote_access_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateRemoteAccess'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostgresqlPgUpdateRemoteAccessResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postgresqlServiceUpdateRemoteAccessWithHttpInfo($service_id, $postgresql_pg_update_remote_access_request, string $contentType = self::contentTypes['postgresqlServiceUpdateRemoteAccess'][0])
    {
        $request = $this->postgresqlServiceUpdateRemoteAccessRequest($service_id, $postgresql_pg_update_remote_access_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PostgresqlPgUpdateRemoteAccessResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PostgresqlPgUpdateRemoteAccessResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PostgresqlPgUpdateRemoteAccessResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PostgresqlPgUpdateRemoteAccessResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostgresqlPgUpdateRemoteAccessResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postgresqlServiceUpdateRemoteAccessAsync
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateRemoteAccessRequest $postgresql_pg_update_remote_access_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateRemoteAccess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceUpdateRemoteAccessAsync($service_id, $postgresql_pg_update_remote_access_request, string $contentType = self::contentTypes['postgresqlServiceUpdateRemoteAccess'][0])
    {
        return $this->postgresqlServiceUpdateRemoteAccessAsyncWithHttpInfo($service_id, $postgresql_pg_update_remote_access_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postgresqlServiceUpdateRemoteAccessAsyncWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateRemoteAccessRequest $postgresql_pg_update_remote_access_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateRemoteAccess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceUpdateRemoteAccessAsyncWithHttpInfo($service_id, $postgresql_pg_update_remote_access_request, string $contentType = self::contentTypes['postgresqlServiceUpdateRemoteAccess'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostgresqlPgUpdateRemoteAccessResponse';
        $request = $this->postgresqlServiceUpdateRemoteAccessRequest($service_id, $postgresql_pg_update_remote_access_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postgresqlServiceUpdateRemoteAccess'
     *
     * @param  string $service_id (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateRemoteAccessRequest $postgresql_pg_update_remote_access_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateRemoteAccess'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postgresqlServiceUpdateRemoteAccessRequest($service_id, $postgresql_pg_update_remote_access_request, string $contentType = self::contentTypes['postgresqlServiceUpdateRemoteAccess'][0])
    {

        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling postgresqlServiceUpdateRemoteAccess'
            );
        }

        // verify the required parameter 'postgresql_pg_update_remote_access_request' is set
        if ($postgresql_pg_update_remote_access_request === null || (is_array($postgresql_pg_update_remote_access_request) && count($postgresql_pg_update_remote_access_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $postgresql_pg_update_remote_access_request when calling postgresqlServiceUpdateRemoteAccess'
            );
        }


        $resourcePath = '/v1/cloud/postgresql/{service_id}/remote-access';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($postgresql_pg_update_remote_access_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($postgresql_pg_update_remote_access_request));
            } else {
                $httpBody = $postgresql_pg_update_remote_access_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postgresqlServiceUpdateRole
     *
     * @param  string $service_id service_id (required)
     * @param  string $role_name role_name (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateRoleRequest $postgresql_pg_update_role_request postgresql_pg_update_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateRole'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PostgresqlPgUpdateRoleResponse
     */
    public function postgresqlServiceUpdateRole($service_id, $role_name, $postgresql_pg_update_role_request, string $contentType = self::contentTypes['postgresqlServiceUpdateRole'][0])
    {
        list($response) = $this->postgresqlServiceUpdateRoleWithHttpInfo($service_id, $role_name, $postgresql_pg_update_role_request, $contentType);
        return $response;
    }

    /**
     * Operation postgresqlServiceUpdateRoleWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $role_name (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateRoleRequest $postgresql_pg_update_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateRole'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PostgresqlPgUpdateRoleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function postgresqlServiceUpdateRoleWithHttpInfo($service_id, $role_name, $postgresql_pg_update_role_request, string $contentType = self::contentTypes['postgresqlServiceUpdateRole'][0])
    {
        $request = $this->postgresqlServiceUpdateRoleRequest($service_id, $role_name, $postgresql_pg_update_role_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PostgresqlPgUpdateRoleResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PostgresqlPgUpdateRoleResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PostgresqlPgUpdateRoleResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PostgresqlPgUpdateRoleResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PostgresqlPgUpdateRoleResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postgresqlServiceUpdateRoleAsync
     *
     * @param  string $service_id (required)
     * @param  string $role_name (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateRoleRequest $postgresql_pg_update_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceUpdateRoleAsync($service_id, $role_name, $postgresql_pg_update_role_request, string $contentType = self::contentTypes['postgresqlServiceUpdateRole'][0])
    {
        return $this->postgresqlServiceUpdateRoleAsyncWithHttpInfo($service_id, $role_name, $postgresql_pg_update_role_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postgresqlServiceUpdateRoleAsyncWithHttpInfo
     *
     * @param  string $service_id (required)
     * @param  string $role_name (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateRoleRequest $postgresql_pg_update_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postgresqlServiceUpdateRoleAsyncWithHttpInfo($service_id, $role_name, $postgresql_pg_update_role_request, string $contentType = self::contentTypes['postgresqlServiceUpdateRole'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PostgresqlPgUpdateRoleResponse';
        $request = $this->postgresqlServiceUpdateRoleRequest($service_id, $role_name, $postgresql_pg_update_role_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postgresqlServiceUpdateRole'
     *
     * @param  string $service_id (required)
     * @param  string $role_name (required)
     * @param  \OpenAPI\Client\Model\PostgresqlPgUpdateRoleRequest $postgresql_pg_update_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postgresqlServiceUpdateRole'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postgresqlServiceUpdateRoleRequest($service_id, $role_name, $postgresql_pg_update_role_request, string $contentType = self::contentTypes['postgresqlServiceUpdateRole'][0])
    {

        // verify the required parameter 'service_id' is set
        if ($service_id === null || (is_array($service_id) && count($service_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $service_id when calling postgresqlServiceUpdateRole'
            );
        }

        // verify the required parameter 'role_name' is set
        if ($role_name === null || (is_array($role_name) && count($role_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $role_name when calling postgresqlServiceUpdateRole'
            );
        }

        // verify the required parameter 'postgresql_pg_update_role_request' is set
        if ($postgresql_pg_update_role_request === null || (is_array($postgresql_pg_update_role_request) && count($postgresql_pg_update_role_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $postgresql_pg_update_role_request when calling postgresqlServiceUpdateRole'
            );
        }


        $resourcePath = '/v1/cloud/postgresql/{service_id}/role/{role_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($service_id !== null) {
            $resourcePath = str_replace(
                '{' . 'service_id' . '}',
                ObjectSerializer::toPathValue($service_id),
                $resourcePath
            );
        }
        // path params
        if ($role_name !== null) {
            $resourcePath = str_replace(
                '{' . 'role_name' . '}',
                ObjectSerializer::toPathValue($role_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($postgresql_pg_update_role_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($postgresql_pg_update_role_request));
            } else {
                $httpBody = $postgresql_pg_update_role_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
